{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/baseHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["export const isObject = (value) => value !== null && typeof value === 'object';\nexport const extend = Object.assign;\nexport const isArray = Array.isArray;\nexport const isFunction = (val) => typeof val === 'function';\nexport const isNumber = (val) => typeof val === 'number';\nexport const isString = (val) => typeof val === 'string';\n// 判断是不是一个数字类型的key\nexport const isIntegerKey = (key) => parseInt(key) + '' === key;\nexport const hasOwn = (target, key) =>\n  Object.prototype.hasOwnProperty.call(target, key);\nexport const hasChanged = (value, oldValue) => value !== oldValue;\n","import { isArray, isIntegerKey } from '@vue/shared';\nimport { TriggerOpTypes } from './operators';\n\nexport function effect(fn, options: any = {}) {\n  // 需要让这个effect变成响应式的effect，可以做到数据变化重新执行\n  const effect = createReactivityEffect(fn, options);\n\n  if (!options.lazy) {\n    // lazy 属性用于标识effect是否是懒执行的\n    effect(); // 响应式的effect默认会先执行一次\n  }\n  return effect;\n}\n\nlet uid = 0;\nlet activeEffect; // 存储当前的effect\nconst effectStack = []; // 存储effect的栈\nfunction createReactivityEffect(fn, options) {\n  const effect = function reactivityEffect() {\n    // 防止出现类似 state.xxx ++ 每次+1都会触发effect执行 死循环的情况\n    if (!effectStack.includes(effect)) {\n      // 保证effect没有加入到effectStack中\n      try {\n        effectStack.push(effect); // 将effect存入effectStack\n        activeEffect = effect; // 此属性会和当前的属性做关联\n        return fn(); // 函数执行时会取值，会执行get方法\n      } finally {\n        // try finally 确保fn出错时，仍能正确出栈\n        effectStack.pop(); // 出栈 将effect移除\n        activeEffect = effectStack[effectStack.length - 1]; // 获取栈中的最后一个\n      }\n    }\n  };\n\n  effect.id = uid++; // effect的唯一标识，组件渲染时会用到这个id\n  effect._isEffect = true; // 用于标识这个是响应式effect\n  effect.raw = fn; // 保留effect对应的原函数\n  effect.options = options; // 在effect上保存用户的属性\n\n  return effect;\n}\n\n// 让某个对象中的属性 收集当前他对应的effect函数\nconst targetMap = new WeakMap();\nexport function track(target, type, key) {\n  // 可以拿到当前的effect\n  // activeEffect; // 当前正在运行的effect\n  if (activeEffect === undefined) {\n    // 此属性不用收集依赖，因为在effect外面使用的\n    return;\n  }\n  // 判断映射表里是否有这个对象\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  // 判断value里是否有这个属性key（name、age）\n  let dep = depsMap.get(key);\n  if (!dep) {\n    // 用set因为一个属性可能有多个effect，所以用一个集合来维护\n    depsMap.set(key, (dep = new Set()));\n  }\n  // 判断当前属性是否有当前的effect\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect); // 收集对应的effect\n  }\n}\n// weekMap key => {name: 'mh', age:27} value (map) => {name => set, age => set}\n// 结构 {name: 'mh', age:27} => name => [effect effect]\n\n// 函数调用是个栈型结构，后进先出 [effect1, effect2]\n// 实现用到堆栈的原因，仅声明activeEffect会导致拿不到正确的effect\n// effect(() => { // effect1\n//   state.name -> effect1\n//   effect(() => { //effect2\n//     state.age; -> effect2\n//   })\n//   state.address -> effect2 应该为 effect1\n// });\n\n// 找属性对应的effect，让其执行（数组、对象）\nexport function trigger(target, type, key?, newValue?, oldValue?) {\n  // 如果这个属性没有收集过effect，那不需要做任何操作\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return;\n\n  const effects = new Set(); // 同一个effect中多个值变化，会合并去重，只会触发一次\n  const add = (effectsToAdd) => {\n    if (effectsToAdd) {\n      effectsToAdd.forEach((effect) => effects.add(effect));\n    }\n  };\n  // 我要将所有的要执行的effect 全部存到一个新的集合中，最终一起执行\n  // 1.如果修改的是数组的长度，会触发数组的length属性，以及索引对应的属性\n  if (key === 'length' && isArray(target)) {\n    // 如果长度有依赖收集，那么修改length时，需要触发依赖收集\n    depsMap.forEach((dep, key) => {\n      // 类似一个hack\n      if (key === 'length' || key > newValue)\n        // length = 1 key = 2 如果更改的长度小于索引，那么对应的索引也需要触发effect重新执行\n        add(dep);\n    });\n  } else {\n    // 可能是对象\n    if (key !== undefined) {\n      // 这里肯定是修改，不能是新增\n      add(depsMap.get(key)); // 如果是新增属性，那么也需要触发effect执行\n    }\n    // 如果添加了一个索引，就触发长度的更新\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        // target是数组且更改的是索引\n        if (isArray(target) && isIntegerKey(key)) {\n          // 虽然改的是索引，但要触发length对应的effect\n          add(depsMap.get('length'));\n        }\n    }\n  }\n  effects.forEach((effect: any) => {\n    if (effect.options.scheduler) {\n      // 有调度器，走调度器\n      effect.options.scheduler(effect);\n    } else {\n      effect();\n    }\n  });\n}\n","// 实现 new Proxy(target, baseHandlers) 的 baseHandlers\n// 是不是仅读的，仅读的属性set时会报异常\n// 是不是深度的\n\nimport {\n  extend,\n  hasChanged,\n  hasOwn,\n  isArray,\n  isIntegerKey,\n  isObject,\n} from '@vue/shared';\nimport { reactive, readonly } from './reactive';\nimport { track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOpTypes } from './operators';\n\nconst get = createGetter();\nconst shallowGet = createGetter(false, true);\nconst readonlyGet = createGetter(true);\nconst shallowReadonlyGet = createGetter(true, true);\n\nconst set = createSetter();\nconst shallowSet = true;\n\nexport const mutableHandlers = {\n  get,\n  set,\n};\nexport const shallowReactiveHandlers = {\n  get: shallowGet,\n  set: shallowSet,\n};\n\nlet readonlyObj = {\n  set: (target, key) => {\n    console.warn(`set key ${key} failed`);\n  },\n};\n\nexport const readonlyHandlers = extend(\n  {\n    get: readonlyGet,\n  },\n  readonlyObj\n);\n\nexport const shallowReadonlyHandlers = extend(\n  {\n    get: shallowReadonlyGet,\n  },\n  readonlyObj\n);\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  // 拦截获取功能\n  return function get(target, key, receiver) {\n    // let proxy = reactive()\n    // proxy + reflect 反射\n    // 后续Object上的方法会被迁移到Reflect上， Object.getPrototypeOf => Reflect.getPrototypeOf\n    // 以前target[key] = value 方式设置值可能会失败，比如原型上有这个属性，但是设置不成功。并不会报异常，也没有返回值标识\n    // Reflect 方法具备返回值，返回值标识是否设置成功\n    // reflect 使用可以不使用proxy 但是proxy必须配合reflect一起使用\n    const res = Reflect.get(target, key, receiver); // target[key]\n    if (!isReadonly) {\n      // 可能被改，收集依赖，等会数据变化后更新对应的视图\n      // console.log('执行ef fect时会取值', '收集effect');\n      track(target, TrackOpTypes.GET, key);\n    }\n    if (shallow) {\n      return res;\n    }\n    // 是对象 有可能要递归\n    if (isObject(res)) {\n      // vue2 是一上来就递归，vue3 是当取值的时候才会代理，vue3的代理模式是懒代理\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\n\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    const oldValue = target[key]; // 获取老的值\n    // 既是数组，修改的也是他的索引 如果索引比数组的长度大，相当于新增\n    let hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver); // target[key] = value\n    // 1. 要区分是新增还是修改 vue2里无法监控更改索引，无法监控数组的长度\n    // 变化 => hack的方法，需要特殊处理\n    if (!hadKey) {\n      // 新增\n      trigger(target, TriggerOpTypes.ADD, key, value);\n    } else if (hasChanged(oldValue, value)) {\n      // 修改\n      trigger(target, TriggerOpTypes.SET, key, value, oldValue);\n    }\n\n    // 当数据更新时，通知对应属性的effect重新执行\n\n    return result;\n  };\n} // 拦截设置功能\n","import { isObject } from '@vue/shared';\nimport {\n  mutableHandlers,\n  shallowReactiveHandlers,\n  readonlyHandlers,\n  shallowReadonlyHandlers,\n} from './baseHandlers';\n\nexport function reactive(target) {\n  return createReactiveObject(target, false, mutableHandlers);\n}\n\nexport function shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers);\n}\n\nexport function readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers);\n}\n\nexport function shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers);\n}\n\n// 是不是仅读，是不是深度 new Proxy() 最核心的需要拦截数据的读取和数据的修改 get set\n// 每个方法都能根据不同的参数处理不同的逻辑（柯里化），根据参数实现不同的功能\n// 内存空间\nconst reactiveMap = new WeakMap(); // 会自动垃圾回收，不会造成内存泄漏，key只能是对象\nconst readonlyMap = new WeakMap();\nexport function createReactiveObject(target, isReadonly, baseHandler) {\n  // 如果目标不是对象，没法拦截，reactive这个api只能拦截对象类型\n  if (!isObject(target)) {\n    return target;\n  }\n  // 如果某个对象已经被代理过了，就不要再次代理了，可能一个对象被代理的是深度，又被仅读代理了\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\n  const existProxy = proxyMap.get(target); // 如果已经被代理过了，就直接返回即可\n  if (existProxy) {\n    return existProxy;\n  }\n  const proxy = new Proxy(target, baseHandler);\n  proxyMap.set(target, proxy); // 将要代理的对象和对应的代理结果缓存起来\n  return proxy;\n}\n","import { hasChanged, isArray, isObject } from '@vue/shared';\nimport { track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOpTypes } from './operators';\nimport { reactive } from './reactive';\n\n/**\n * ref和reactive的区别\n * reactive内部采用的是proxy，而ref内部使用的是defineProperty\n * reactive处理不了基本类型，ref可以处理基本类型\n */\nexport function ref(value) {\n  // value是一个普通类型，也可以是对象，但是一般情况下是对象直接用reactive更合理\n  // 将普通类型变成一个对象\n  return createRef(value);\n}\n\nexport function shallowRef(value) {\n  return createRef(value, true);\n}\n\n// 后续 看vue的源码，基本都是高阶函数，做了类似柯里化的操作\n\nconst convert = (val) => (isObject(val) ? reactive(val) : val);\n// beta 版本之前的版本ref就是个对象，因为对象不方便扩展，改成了类\n\n// RefImpl经babel转义后是Object.defineProperty 可通过 https://babeljs.io/repl 查看\n// 基本类型为什么不用proxy, 而是用defineProperty, 因为proxy第一个参数要求是对象\nclass RefImpl {\n  public _value; // 表示 声明了一个_value属性，但是没有赋值\n  public __v_isRef = true; // 产生的实例会被添加__v_isRef 表示是一个ref属性\n  constructor(public rawValue, public shallow) {\n    //参数中前面增加修饰符 表示此属性放到了实例上, 不加public，就不会放到this上\n    this._value = shallow ? rawValue : convert(rawValue); // 如果是深度的，需要把里面的都变成响应式的\n  }\n  // 类的属性访问器\n  get value() {\n    // 代理 取值取value，会帮我们代理到_value上\n    // 取值 track 依赖收集\n    track(this, TrackOpTypes.GET, 'value');\n    return this._value;\n  }\n  set value(newValue) {\n    if (hasChanged(newValue, this.rawValue)) {\n      // 判断老值和新值是否有变化\n      this.rawValue = newValue; // 更新老值\n      this._value = this.shallow ? newValue : convert(newValue); // 更新_value\n    }\n    // 设置值 trigger 触发依赖更新 让effect重新执行\n    trigger(this, TriggerOpTypes.SET, 'value', newValue);\n  }\n}\n\nfunction createRef(rawValue, shallow = false) {\n  return new RefImpl(rawValue, shallow);\n}\n\nclass ObjectRefImpl {\n  public __v_isRef = true;\n  constructor(public target, public key) {}\n  get value() {\n    return this.target[this.key]; // 如果原来对象是响应式的，会自动收集依赖\n  }\n  set value(newValue) {\n    this.target[this.key] = newValue; // 如果原来对象是响应式的，会自动更新\n  }\n}\n\n// 类似promisify和promisifyAll\n\n// 将某一个key的对应的值 转换成ref 相当于vue3中的响应式解构\nexport function toRef(target, key) {\n  // 可以把一个对象的值转换成ref类型\n  return new ObjectRefImpl(target, key);\n}\n\nexport function toRefs(object) {\n  // object可能是数组或者对象\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (let key in object) {\n    ret[key] = toRef(object, key);\n  }\n  return ret;\n}\n","import { isFunction } from '@vue/shared';\nimport { effect, track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOpTypes } from './operators';\n\nclass ComputedRefImpl {\n  public _dirty = true; // 默认取值时，不要用缓存\n  public _value;\n  public effect;\n  constructor(getter, public setter) {\n    // ts中默认不会挂载到this上，可以加public\n    this.effect = effect(getter, {\n      // 计算属性默认会产生一个effect\n      lazy: true, // 默认不执行\n      scheduler: () => {\n        // 依赖变化后执行\n        if (!this._dirty) {\n          this._dirty = true; // 设置为true，重新执行effect\n          // 依赖的属性变化，通知对应的effect重新执行\n          trigger(this, TriggerOpTypes.SET, 'value');\n        }\n      },\n    });\n  }\n  get value() {\n    // 计算属性也要收集依赖 vue2中不具备收集依赖的功能\n    if (this._dirty) {\n      this._value = this.effect(); // 会将用户的返回值返回\n      this._dirty = false;\n    }\n    // 当访问了this的value属性时，就做一个依赖收集\n    track(this, TrackOpTypes.GET, 'value');\n    return this._value;\n  }\n  set value(newValue) {\n    this.setter(newValue);\n  }\n}\n\n// vue2 和 vue3 computed原理是不一样的\n// vue2 是一个watcher，vue3是一个特殊的effect\nexport function computed(getterOrOptions) {\n  // 如果是函数，就是一个getter\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n    setter = () => {\n      console.warn('computed value must be readonly');\n    };\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  return new ComputedRefImpl(getter, setter);\n}\n\n/**\n * 注：example中age是父级 myAge计算属性是儿子\n * 1. 让自己的儿子把自己收集起来，所以他自己是个effect line11\n * 2. 取值的过程中让他父级也能收集他自己，所以取值的时候也要收集依赖 line29\n * 3. 当他儿子更新了，除了修改自己的dirty属性，还要通知父级收集的依赖也要更新 line18\n */\n"],"names":[],"mappings":"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"}